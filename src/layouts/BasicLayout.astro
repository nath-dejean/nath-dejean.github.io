---
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../consts";
import "../styles/global.css";
---

<!doctype html>
<html lang="en">
    <head>
        <BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
    </head>
    <body>
        <div class="background-canvas" aria-hidden="true">
            <div class="bg-grid"></div>
            <div class="bg-orb orb-magenta"></div>
            <div class="bg-orb orb-cyan"></div>
            <div class="bg-orb orb-amber"></div>
        </div>
        <div class="layout-shell">
            <Header />
            <main>
                <slot />
            </main>
            <Footer />
        </div>
        <script is:inline>
            (function(){
                const root = document.documentElement;
                const body = document.body;
                const canvas = document.querySelector('.background-canvas');
                if (!canvas) return;
                const orbs = Array.from(canvas.querySelectorAll('.bg-orb'));
                const grid = canvas.querySelector('.bg-grid');

                const state = { x: 0, y: 0, targetX: 0, targetY: 0 };

                function animate(){
                    state.x += (state.targetX - state.x) * 0.08;
                    state.y += (state.targetY - state.y) * 0.08;

                    orbs.forEach((orb, index) => {
                        const depth = 12 + index * 6;
                        orb.style.transform = `translate3d(${state.x / depth}%, ${state.y / depth}%, 0)`;
                    });

                    if (grid) {
                        grid.style.transform = `rotate(12deg) scale(1.2) translate3d(${state.x / 35}%, ${state.y / 28}%, 0)`;
                    }

                    requestAnimationFrame(animate);
                }

                window.addEventListener('pointermove', (event) => {
                    const xRatio = (event.clientX / root.clientWidth) - 0.5;
                    const yRatio = (event.clientY / window.innerHeight) - 0.5;
                    state.targetX = xRatio * 24;
                    state.targetY = yRatio * 18;
                }, { passive: true });

                animate();

                // Scroll elevation state for header styling
                let ticking = false;
                function handleScroll(){
                    body.classList.toggle('is-scrolled', window.scrollY > 28);
                    ticking = false;
                }

                window.addEventListener('scroll', () => {
                    if (!ticking) {
                        requestAnimationFrame(handleScroll);
                        ticking = true;
                    }
                }, { passive: true });

                handleScroll();

                // Reveal animations when sections enter viewport
                const revealables = document.querySelectorAll('.reveal');
                if (revealables.length) {
                    const observer = new IntersectionObserver((entries) => {
                        entries.forEach((entry) => {
                            if (entry.isIntersecting) {
                                entry.target.classList.add('is-visible');
                                observer.unobserve(entry.target);
                            }
                        });
                    }, { threshold: 0.15, rootMargin: '0px 0px -10%' });

                    revealables.forEach((element) => observer.observe(element));
                }
            })();
        </script>
    </body>
</html>