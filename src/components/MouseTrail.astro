<style>
	:global(:root) {
		--color-bg: #050511;
		--color-bg-alt: #0c1025;
		--color-surface: rgba(255, 255, 255, 0.06);
		--color-surface-strong: rgba(255, 255, 255, 0.12);
		--color-primary: #6cf3ff;
		--color-secondary: #a772ff;
		--color-tertiary: #ffb376;
		--color-text: #f4f7ff;
		--color-muted: #8d95b8;
		--color-line: rgba(255, 255, 255, 0.08);
	}

	canvas#orb-canvas {
		position: fixed;
		top: 0;
		left: 0;
		pointer-events: none;
		z-index: 0;
	}
</style>

<canvas id="orb-canvas"></canvas>

<script is:inline>
	const canvas = document.getElementById("orb-canvas");
	const ctx = canvas.getContext("2d");

	let width = window.innerWidth;
	let height = window.innerHeight;
	canvas.width = width;
	canvas.height = height;

	window.addEventListener("resize", () => {
		width = window.innerWidth;
		height = window.innerHeight;
		canvas.width = width;
		canvas.height = height;
	});

	// Read palette from CSS variables with fallbacks
	const styles = getComputedStyle(document.documentElement);
	const palette = [
		styles.getPropertyValue("--color-primary").trim() || "#6cf3ff",
		styles.getPropertyValue("--color-secondary").trim() || "#a772ff",
	];

	function parseColorToRgb(color) {
		color = color.trim();
		if (color.startsWith("#")) {
			let hex = color.slice(1);
			if (hex.length === 3) {
				hex = hex.split("").map(c => c + c).join("");
			}
			const int = parseInt(hex, 16);
			return { r: (int >> 16) & 255, g: (int >> 8) & 255, b: int & 255 };
		} else if (color.startsWith("rgb")) {
			const nums = color.replace(/rgba?\(|\)|\s/g, "").split(",").map(Number);
			return { r: nums[0], g: nums[1], b: nums[2] };
		}
		// Fallback: treat unknown as white
		return { r: 255, g: 255, b: 255 };
	}

	function withAlpha(color, a) {
		const { r, g, b } = parseColorToRgb(color);
		return `rgba(${r}, ${g}, ${b}, ${a})`;
	}

	const orbs = [];

	class Orb {
		constructor(x, y) {
			this.x = x;
			this.y = y;
			this.alpha = 1;
			this.size = Math.random() * 10 + 4;
			this.dx = (Math.random() - Math.random(0.2, 0.8)) * 1.5;
			this.dy = (Math.random() - Math.random(0.2, 0.8)) * 1.5;
			this.color = palette[Math.floor(Math.random() * palette.length)];
			this.sparkle = Math.random() > 0.8;
		}

		update() {
			this.x += this.dx;
			this.y += this.dy;
			this.alpha -= 0.01;
		}

		draw() {
			ctx.save();
			ctx.globalAlpha = Math.max(this.alpha, 0);

			const gradient = ctx.createRadialGradient(
				this.x,
				this.y,
				0,
				this.x,
				this.y,
				this.size
			);

			gradient.addColorStop(0, withAlpha(this.color, 1));
			gradient.addColorStop(1, withAlpha(this.color, 0));

			ctx.beginPath();
			ctx.fillStyle = gradient;
			ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
			ctx.fill();

			if (this.sparkle) {
				ctx.beginPath();
				ctx.moveTo(this.x - this.size / 2, this.y);
				ctx.lineTo(this.x + this.size / 2, this.y);
				ctx.moveTo(this.x, this.y - this.size / 2);
				ctx.lineTo(this.x, this.y + this.size / 2);
				ctx.strokeStyle = withAlpha(this.color, 0.6);
				ctx.lineWidth = 0.5;
				ctx.stroke();
			}

			ctx.restore();
		}
	}

	function animate() {
		ctx.clearRect(0, 0, width, height);
		for (let i = orbs.length - 1; i >= 0; i--) {
			const orb = orbs[i];
			orb.update();
			orb.draw();
			if (orb.alpha <= 0) {
				orbs.splice(i, 1);
			}
		}
		requestAnimationFrame(animate);
	}

	document.addEventListener("click", (e) => {
		for (let i = 0; i < 25; i++) {
			orbs.push(new Orb(e.clientX, e.clientY));
		}
	});

	animate();
</script>